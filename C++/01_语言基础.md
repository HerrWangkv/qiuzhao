# C++ 中的四种智能指针
智能指针的本质是一个类。当超出了类的作用域时，类会自动调用析构函数并释放资源(包含其原生指针)，避免造成内部泄露。

- `auto_ptr` (已被弃用)
- `unique_ptr` 保证同一时间内只有一个智能指针可以指向该对象
- `shared_ptr` 多个智能指针可以指向相同对象，该对象和其相关资源会在最后一个引用被销毁(引用计数为0)时释放
- `weak_ptr` 指向一个`shared_ptr`管理的对象，但`weak_ptr`的构造和析构不会引起引用计数的增加或减少。主要用于解决两`shared_ptr`互相引用的问题(此时引用计数不可能下降为0，资源永远不会释放。解决方法是将其中一个改为`weak_ptr`)

见[smart_ptr.cxx](src/smart_ptr.cxx)

# C++中内存分配情况
- 栈: 由**编译器**管理分配和回收,存放**局部变量和函数参数**。
- 堆: 由**程序员**管理,需要手动 new malloc delete free 进行分配和回收,空间较大,但可能会出现内存泄漏和空闲碎片的情况。
- 全局/静态存储区: 分为初始化和未初始化两个相邻区域,存储初始化和未初始化的全局变量和静态变量。
- 常量存储区:存储常量,一般不允许修改。
- 代码区:存放程序的二进制代码。
```cpp
int a = 0; // 全局初始化区
char *p1; // 全局未初始化区

int main(){

    int b; // 栈
    char s[] = "abc"; // s在栈上， "abc\0"在常量区
    char *p2; // 栈
    char *p3 = "123456"; // "123456\0"在常量区，p3在栈上。
    static int c =0; // 全局(静态)初始化区
    p1 = (char *)malloc(10); // 堆
    p2 = (char *)malloc(20); // 堆
    return 0;
}
```
# C++ 中的指针参数传递和引用参数传递
- 指针参数实际上是值传递，传递的是地址值。但这也意味着函数中直接对该地址形参的操作**不会影响**主调函数函数中的地址
- 引用参数传递中被调函数对形参的任何操作都会影响主调函数中的实参

见[ptrVSref.cxx](src/ptrVSref.cxx)

# `static`关键字
1. 修饰局部变量：局部变量一般存放在**栈区，生命周期与作用域(语句块)相同**。但如果用`static`对局部变量进行修饰，则该变量会被存放在**静态数据区，且生命周期会持续到整个程序执行结束**。[static1.cxx](src/static1.cxx)
2. 修饰全局变量：一般情况下，全局变量既可以在本文件中被访问，也可以在同一个工程中其他源文件被访问(添加`extern`声明即可)。但如果用`static`对全局变量进行修饰，则该全局变量的作用域被改变，变成了**仅本文件可见**。注意不要在头文件中定义全局变量，如果该头文件被多次include，会出现多重定义问题。[static2](src/static2/main.cxx)
3. 修饰函数：同样改变函数作用域，变成仅本文件可见。[static3](src/static3/main.cxx)
4. 修饰类：静态函数/数据成员声明之前加上关键字static使得其与类而非对象关联在一起。[static4](src/static4/main.cxx)
   1. 类作用域外使用 类名+作用域运算符(::)直接访问 或者 该类的对象/引用/指针+成员访问符(. / ->)访问静态函数/数据成员
   2. 成员函数不用通过作用域运算符就能直接使用静态成员
   3. **静态函数成员**可以在类内定义，也可以在类外定义。但在类外部定义静态成员函数时，不能重复static关键字。static函数体内不能使用this指针。但不是所用需要用到静态成员的函数都必须声明为static。
   4. **静态数据成员**不属于类的任何一个对象，故他们不能由类的构造函数初始化。此外我们 **一般情况下** 不能对静态数据成员进行类内初始化，**需要在类的外部定义和初始化**每个**非常量**静态数据成员，且一个静态数据成员只能定义一次(但可以多次赋值)。类外定义静态数据成员也不能重复static关键字。确保对象仅被定义一次的最佳方法是把静态数据成员的定义与其他费内敛函数的定义放在同一个文件中。
   5. 静态数据成员可以是[不完全类型](#33-类类型)(仅声明未定义的类类型)，而非静态成员不可以。特别的，静态数据成员的类型可以就是它所属的类类型。
    ```cpp
    class Bar {
    public:
        ...
    private:
        static Bar mem1;//正确
        Bar *mem2;//正确
        Bar mem3;//错误
    };
    ```
    6. **静态函数成员**不能访问非`static`的类成员，也不能被`virtual`修饰。

# `const`关键字
## 顶层`const`
1. 基本数据类型 
   - const对象 可以被 同类型 非const对象 初始化
   - const对象 可以用于初始化 同类型 非const对象
    ```cpp
    int i = 42;
    const int j = i;
    int k = j;
    ```
2. 常量指针
   
   常量指针指向的地址不变，但被指对象的值可以变。
    ```cpp
    int i = 0;
    int *const cptr = &i; // cptr一直指向i
    *cptr = 42;
    ```

## 底层const
1. 常量引用
   - const对象 不能被 非常量引用 绑定
   - const引用 可以绑定 同类型 或 其他类型但可以进行类型转换的 非常量(有可能改变值)
   - 常量引用可以绑定字面常量
    ```cpp
    double pi = 3.14;//
    const int &rpi = pi; //正确，但rpi=3，且不可改变
    int &rpi2 = rp1; // 报错
    const int &r = 42;// 正确，常量引用可以绑定字面常量
    int &r2 = 42;// 报错
    ```
2. 指向常量的指针
   - 普通指针 不能指向 常量
   - 指向常量的指针 可以指向 同类型的 非常量
   - 指向常量的指针可以更改所指对象
    ```cpp
    double pi = 3.14;
    const double *cptr1 = &pi; //定义并初始化一个 指向常量的指针
    const int *cptr2 = &pi; //报错，跟引用略有区别，数据类型不能变
    double *cptr3 = cptr1; // 报错

    void print(const int *beg, const *int end) {
      while (beg != end)
        cout << *beg++ <<endl; //正确，可以更换所指对象
    }
    ```

3. const_iterator

   如果容器是const，迭代器只能用const_iterator，此时对容器只读不写。普通容器既可用const_iterator也可用iterator
   
4. 类的 const 成员函数(将非常量成员暂时视为常量成员，除声明为mutable的成员外均不可改变)
   ```cpp
   std::string isbn() const { return this->bookNo; }//等价
   ```
   紧随参数列表之后的const关键字修改了隐式this指针的类型:从**指向非常量的常量指针**到**指向常量的常量指针**。
   
   常量对象以及常量对象的引用或指针都**只能调用常量成员函数**。

5. 动态分配的const对象

   分配出指向常量的指针。内置类型的const对象不能默认初始化，定义了默认构造函数的类类型可以默认初始化
    ```cpp
    const int *pci = new const int(1024);
    const string *pcs = new const string;
    ```

# C 和 C++ 区别
1. C++ 有新增的语法和关键字
- C++ 中在 malloc 和 free 的基础上增加了 new 和 delete
 - C++ 中在指针的基础上增加了引用的概念
 - C++中还增加了 auto,explicit 体现显示和隐式转换上的概念要求,还有 dynamic_cast 增加类型安全方面的内容
2. C++ 中有重载和虚函数的概念
3. C++ 中的 struct 不仅可以有成员变量还可以成员函数， C++ 还添加了 class
4. C++ 中增加了模板还重用代码,提供了更加强大的 STL 标准库。

# C++ 和 java 区别

# C++ 里是怎么定义常量的?
- 局部常量：存放在栈区
- 全局常量：编译期一般不分配内存,放在符号表中以提高访问效率
- 字面值常量：比如字符串,放在常量区。

# C++ 中重载和重写,重定义的区别
- 重载：overload, 是指同一可访问区内被声明的几个具有不同参数列表的同名函数。仅返回类型不同不叫重载
- 重写：override, **派生类**中重新定义**父类**中除了函数体外(函数名字、参数表及返回类型)完全相同的**虚函数**。尽管 virtual 中是 private 的,派生类中重写可以改为 public。
- 重定义(隐藏)：redefine, 派生类重新定义父类中的非虚函数, 基类中所有参数列表和返回类型不完全相同的同名函数都被隐藏。

(实际上重定义和重写的区别主要在于多态性？)，见[overload_vs_override_vs_redefine.cxx](src/overload_vs_override_vs_redefine.cxx)

# C++所有构造函数
- 默认构造函数：编译器自动生成默认的无参数构造函数。
- 一般构造函数：重载构造函数，创建时根据传入参数不同调用不同的构造函数
- 类型转换构造函数：一般构造函数的一种，根据一个指定类型的对象创建一个本类对象。如果想要**阻止隐式转换**，需要声明为`explicit`
- 拷贝构造函数：参数为对象本身的const引用，根据一个已存在的对象复制出一个**新的该类的对象**。如果没有显式的拷贝构造函数，编译器会默认创建一个拷贝构造函数。但当类中有指针成员时，最好不要使用编译器默认的拷贝构造函数
- 拷贝赋值运算符：类似拷贝构造函数。如果没有显式的赋值运算符，编译器也会生成默认的拷贝赋值运算符
- 移动构造函数
- 移动赋值运算符

[constructor.cxx](src/constructor.cxx)

# C++的四种强制转换
- `static_cast`: 明确指出类型转换，没有动态类型检查，故上行转换(派生->基类)安全，下行转换(基类->派生)不安全
- `dynamic_cast`: 专门用于派生类之间的转换，下行转换(基类->派生)安全
- `const_cast`: 专⻔用于 const 属性的转换,去除 const 性质,或增加 const 性质
- `reinterpret_cast`: 从底层对数据进行重新解释,依赖具体的平台,可移植性差。避免使用

# 指针和引用的区别
- 在程序编译的时候，指针和引用都会被添加到符号表中。
- 指针指向一块内存，指针的值是该内存的地址。编译的时候，将**指针变量名-指针变量的地址**添加到符号表中。指针包含的值是可以改变的。
- 引用只是一块内存的别名。编译的时候，将**引用变量名-引用对象的地址**添加到符号表中。引用必须而且只能在定义时被绑定到一块内存上,后续不能更改。
- `sizeof`引用得到代表对象的大小，`sizeof`指针得到的是指针本身的大小。
- 指针需要被解引用后才可以对对象进行操作，而引用可以直接操作被引用对象。
- 作为参数时，传指针的实质是传值；传引用的实质是传地址。

# 野(wild)指针与悬空(dangling)指针的区别
- 野指针(wild pointer):就是没有被初始化过的指针。用 `gcc -Wall` 编译, 会出现 `used uninitialized` 警告。
- 悬空指针(dangling pointer):是指针最初指向的内存已经被释放了的一种指针。

# `const`修饰指针如何区分
`const`右侧最近的内容为常量。
- `const int *p1;`: 指向**整形常量**的指针，指向的值不能修改
- `int *const p2`: 指向整形的**常量指针**，不能再指向别的变量
- `const int *const p3;`: 指向**整形常量**的**常量指针**

# 函数指针
